<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Visualizer for YouTube - Enhanced</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(45deg, #0a0a0a, #1a1a2e, #16213e);
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #visualizer {
            width: 100vw;
            height: 100vh;
            background: radial-gradient(ellipse at center, rgba(255,255,255,0.1) 0%, transparent 70%);
            position: relative;
        }

        canvas {
            display: block;
            background: transparent;
        }

        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            max-width: 90vw;
        }

        .control-group {
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            min-width: 200px;
        }

        .control-group h4 {
            margin: 0 0 10px 0;
            color: #fff;
            font-size: 14px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 5px;
        }

        input[type="file"] {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }

        input[type="file"]:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        input[type="color"] {
            width: 40px;
            height: 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 2px;
        }

        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        select {
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 8px;
            border-radius: 5px;
            margin: 5px;
            width: 100%;
        }

        label {
            color: white;
            font-size: 12px;
            display: block;
            margin: 5px 0 2px 0;
        }

        .color-preset {
            display: flex;
            gap: 5px;
            margin: 5px 0;
            flex-wrap: wrap;
        }

        .preset-btn {
            padding: 5px 10px;
            font-size: 11px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            border-radius: 3px;
            cursor: pointer;
        }

        .preset-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: none;
            box-shadow: none;
        }

        .info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: rgba(255,255,255,0.7);
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }

        .slider-group span {
            color: white;
            font-size: 11px;
            min-width: 30px;
        }
    </style>
</head>
<body>
    <div id="visualizer">
        <canvas id="canvas"></canvas>
        
        <div class="controls">
            <div class="control-group">
                <h4>üìÅ Audio Controls</h4>
                <input type="file" id="audioFile" accept="audio/*,.mp3,.wav,.ogg,.m4a">
                <button id="playBtn" disabled>Play</button>
                <button id="pauseBtn" disabled>Pause</button>
            </div>
            
            <div class="control-group">
                <h4>üé® Visualization</h4>
                <label>Mode:</label>
                <select id="visualMode">
                    <option value="bars">Classic Bars</option>
                    <option value="bars_mirror">Mirror Bars ‚≠ê</option>
                    <option value="bars_center">Center Bars</option>
                    <option value="bars_radial">Radial Bars</option>
                    <option value="bars_wave">Wave Bars</option>
                    <option value="bars_stacked">Stacked Bars</option>
                    <option value="circle">Circular</option>
                    <option value="waveform">Waveform</option>
                    <option value="particles">Particles</option>
                    <option value="spiral">Spiral</option>
                </select>
            </div>

            <div class="control-group">
                <h4>üé® Color Scheme</h4>
                <label>Color Mode:</label>
                <select id="colorMode">
                    <option value="rainbow">Rainbow Spectrum</option>
                    <option value="custom">Custom Colors</option>
                    <option value="gradient">Two-Color Gradient</option>
                    <option value="monochrome">Monochrome</option>
                </select>
                
                <div id="customColors" style="display: none;">
                    <label>Primary:</label>
                    <input type="color" id="color1" value="#ff6b6b">
                    <label>Secondary:</label>
                    <input type="color" id="color2" value="#4ecdc4">
                    <label>Accent:</label>
                    <input type="color" id="color3" value="#45b7d1">
                </div>

                <div class="color-preset">
                    <button class="preset-btn" onclick="setColorPreset('neon')">Neon</button>
                    <button class="preset-btn" onclick="setColorPreset('ocean')">Ocean</button>
                    <button class="preset-btn" onclick="setColorPreset('sunset')">Sunset</button>
                    <button class="preset-btn" onclick="setColorPreset('cyberpunk')">Cyber</button>
                </div>
            </div>

            <div class="control-group">
                <h4>üìè Size & Scale</h4>
                <div class="slider-group">
                    <label>Visualizer Scale:</label>
                    <input type="range" id="visualizerScale" min="0.3" max="2" step="0.1" value="1">
                    <span id="scaleValue">1.0x</span>
                </div>
                
                <div class="slider-group">
                    <label>Bar Sensitivity:</label>
                    <input type="range" id="sensitivity" min="0.5" max="3" step="0.1" value="1">
                    <span id="sensitivityValue">1.0x</span>
                </div>
            </div>
            
            <div class="control-group">
                <h4>üñºÔ∏è Background</h4>
                <input type="file" id="backgroundImage" accept="image/*" style="font-size: 12px; padding: 5px;">
                <button id="clearBg">Clear BG</button>
                
                <div class="slider-group">
                    <label>BG Opacity:</label>
                    <input type="range" id="bgOpacity" min="0.1" max="1" step="0.1" value="0.7">
                    <span id="opacityValue">0.7</span>
                </div>
                
                <div class="slider-group">
                    <label>BG Scale:</label>
                    <input type="range" id="bgScale" min="0.5" max="2" step="0.1" value="1">
                    <span id="bgScaleValue">1.0x</span>
                </div>
            </div>
        </div>

        <div class="info">
            <div>Upload an audio file to start visualizing</div>
            <div>Supported formats: MP3, WAV, OGG, M4A</div>
            <div>Perfect for screen recording for YouTube videos</div>
        </div>
    </div>

    <audio id="audio" style="display: none;"></audio>

    <script>
        class AudioVisualizer {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.audio = document.getElementById('audio');
                this.audioContext = null;
                this.analyser = null;
                this.dataArray = null;
                this.source = null;
                this.animationId = null;
                this.currentFileName = '';
                this.backgroundImage = null;
                
                this.particles = [];
                this.visualMode = 'bars_mirror';
                this.colorMode = 'rainbow';
                this.customColors = ['#ff6b6b', '#4ecdc4', '#45b7d1'];
                this.visualizerScale = 1;
                this.sensitivity = 1;
                this.bgOpacity = 0.7;
                this.bgScale = 1;
                
                this.setupCanvas();
                this.setupEventListeners();
                this.setupParticles();
            }
            
            setupCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                });
            }
            
            setupEventListeners() {
                const fileInput = document.getElementById('audioFile');
                const playBtn = document.getElementById('playBtn');
                const pauseBtn = document.getElementById('pauseBtn');
                const visualMode = document.getElementById('visualMode');
                const colorMode = document.getElementById('colorMode');
                const backgroundInput = document.getElementById('backgroundImage');
                const clearBgBtn = document.getElementById('clearBg');
                
                // Audio controls
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.currentFileName = file.name;
                        this.loadAudio(file);
                    }
                });
                
                playBtn.addEventListener('click', () => this.play());
                pauseBtn.addEventListener('click', () => this.pause());
                
                // Visual controls
                visualMode.addEventListener('change', (e) => {
                    this.visualMode = e.target.value;
                    if (this.visualMode === 'particles') {
                        this.setupParticles();
                    }
                });
                
                colorMode.addEventListener('change', (e) => {
                    this.colorMode = e.target.value;
                    const customDiv = document.getElementById('customColors');
                    customDiv.style.display = e.target.value === 'custom' || e.target.value === 'gradient' ? 'block' : 'none';
                });
                
                // Color inputs
                document.getElementById('color1').addEventListener('change', (e) => {
                    this.customColors[0] = e.target.value;
                });
                document.getElementById('color2').addEventListener('change', (e) => {
                    this.customColors[1] = e.target.value;
                });
                document.getElementById('color3').addEventListener('change', (e) => {
                    this.customColors[2] = e.target.value;
                });
                
                // Scale controls
                document.getElementById('visualizerScale').addEventListener('input', (e) => {
                    this.visualizerScale = parseFloat(e.target.value);
                    document.getElementById('scaleValue').textContent = this.visualizerScale.toFixed(1) + 'x';
                });
                
                document.getElementById('sensitivity').addEventListener('input', (e) => {
                    this.sensitivity = parseFloat(e.target.value);
                    document.getElementById('sensitivityValue').textContent = this.sensitivity.toFixed(1) + 'x';
                });
                
                // Background controls
                backgroundInput.addEventListener('change', (e) => this.loadBackground(e));
                clearBgBtn.addEventListener('click', () => this.clearBackground());
                
                document.getElementById('bgOpacity').addEventListener('input', (e) => {
                    this.bgOpacity = parseFloat(e.target.value);
                    document.getElementById('opacityValue').textContent = this.bgOpacity.toFixed(1);
                });
                
                document.getElementById('bgScale').addEventListener('input', (e) => {
                    this.bgScale = parseFloat(e.target.value);
                    document.getElementById('bgScaleValue').textContent = this.bgScale.toFixed(1) + 'x';
                });
            }
            
            setupParticles() {
                this.particles = [];
                const particleCount = Math.floor(100 * this.visualizerScale);
                for (let i = 0; i < particleCount; i++) {
                    this.particles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        size: Math.random() * 3 + 1,
                        hue: Math.random() * 360
                    });
                }
            }
            
            loadBackground(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const img = new Image();
                img.onload = () => {
                    this.backgroundImage = img;
                    console.log('Background image loaded');
                };
                img.onerror = () => {
                    console.error('Failed to load background image');
                    alert('Failed to load background image. Please try a different file.');
                };
                img.src = URL.createObjectURL(file);
            }
            
            clearBackground() {
                this.backgroundImage = null;
                document.getElementById('backgroundImage').value = '';
                console.log('Background cleared');
            }
            
            getColor(index, total, intensity = 1) {
                switch (this.colorMode) {
                    case 'rainbow':
                        const hue = (index / total) * 360;
                        const saturation = 70 + (intensity * 30);
                        const lightness = 50 + (intensity * 30);
                        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    
                    case 'custom':
                        const colorIndex = Math.floor((index / total) * this.customColors.length);
                        return this.customColors[colorIndex] || this.customColors[0];
                    
                    case 'gradient':
                        const ratio = index / total;
                        const color1 = this.hexToRgb(this.customColors[0]);
                        const color2 = this.hexToRgb(this.customColors[1]);
                        const r = Math.floor(color1.r + (color2.r - color1.r) * ratio);
                        const g = Math.floor(color1.g + (color2.g - color1.g) * ratio);
                        const b = Math.floor(color1.b + (color2.b - color1.b) * ratio);
                        return `rgba(${r}, ${g}, ${b}, ${intensity})`;
                    
                    case 'monochrome':
                        const brightness = 50 + (intensity * 50);
                        return `hsl(220, 30%, ${brightness}%)`;
                    
                    default:
                        return `hsl(${(index / total) * 360}, 80%, 60%)`;
                }
            }
            
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : {r: 255, g: 107, b: 107};
            }
            
            loadAudio(file) {
                console.log('Loading file:', file.name, 'Type:', file.type, 'Size:', file.size);
                
                const url = URL.createObjectURL(file);
                this.audio.src = url;
                
                this.audio.addEventListener('loadedmetadata', () => {
                    console.log('Audio metadata loaded successfully');
                    document.getElementById('playBtn').disabled = false;
                    document.getElementById('pauseBtn').disabled = false;
                    
                    document.querySelector('.info').innerHTML = `
                        <div style="color: #00ff88;">‚úì Audio loaded: ${this.currentFileName}</div>
                        <div>Duration: ${Math.floor(this.audio.duration / 60)}:${Math.floor(this.audio.duration % 60).toString().padStart(2, '0')}</div>
                        <div>Click Play to start visualization</div>
                    `;
                });
                
                this.audio.addEventListener('error', (e) => {
                    console.error('Audio loading error:', e);
                    this.startDemoVisualization();
                    document.querySelector('.info').innerHTML = `
                        <div style="color: #ff6b6b;">‚ö† Audio format issue - showing demo</div>
                        <div>Try converting to standard MP3 format</div>
                        <div>Demo visualization running</div>
                    `;
                });
            }
            
            async play() {
                try {
                    if (!this.audioContext) {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        this.analyser = this.audioContext.createAnalyser();
                        this.analyser.fftSize = 512;
                        this.analyser.smoothingTimeConstant = 0.8;
                        this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                        
                        this.source = this.audioContext.createMediaElementSource(this.audio);
                        this.source.connect(this.analyser);
                        this.analyser.connect(this.audioContext.destination);
                    }
                    
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                    
                    await this.audio.play();
                    this.startVisualization();
                    
                } catch (error) {
                    console.error('Error playing audio:', error);
                    this.startDemoVisualization();
                }
            }
            
            pause() {
                this.audio.pause();
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }
            
            startVisualization() {
                const animate = () => {
                    if (this.audio.paused) return;
                    this.animationId = requestAnimationFrame(animate);
                    
                    if (this.analyser && this.dataArray) {
                        this.analyser.getByteFrequencyData(this.dataArray);
                        this.draw();
                    }
                };
                animate();
            }
            
            startDemoVisualization() {
                this.dataArray = new Uint8Array(256);
                
                const animate = () => {
                    this.animationId = requestAnimationFrame(animate);
                    
                    const time = Date.now() * 0.001;
                    for (let i = 0; i < this.dataArray.length; i++) {
                        this.dataArray[i] = Math.abs(Math.sin(time + i * 0.1) * 128 + Math.sin(time * 2 + i * 0.05) * 64);
                    }
                    
                    this.draw();
                };
                animate();
            }
            
            draw() {
                // Clear canvas
                if (this.backgroundImage) {
                    this.ctx.globalAlpha = this.bgOpacity;
                    const scaledWidth = this.canvas.width * this.bgScale;
                    const scaledHeight = this.canvas.height * this.bgScale;
                    const offsetX = (this.canvas.width - scaledWidth) / 2;
                    const offsetY = (this.canvas.height - scaledHeight) / 2;
                    this.ctx.drawImage(this.backgroundImage, offsetX, offsetY, scaledWidth, scaledHeight);
                    this.ctx.globalAlpha = 1.0;
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                } else {
                    this.ctx.fillStyle = 'rgba(10, 10, 10, 0.2)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }
                
                // Apply scaling transform
                this.ctx.save();
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                this.ctx.translate(centerX, centerY);
                this.ctx.scale(this.visualizerScale, this.visualizerScale);
                this.ctx.translate(-centerX, -centerY);
                
                if (!this.dataArray || this.dataArray.every(val => val === 0)) {
                    this.drawDefaultAnimation();
                    this.ctx.restore();
                    return;
                }
                
                switch (this.visualMode) {
                    case 'bars': this.drawBars(); break;
                    case 'bars_mirror': this.drawBarsMirror(); break;
                    case 'bars_center': this.drawBarsCenter(); break;
                    case 'bars_radial': this.drawBarsRadial(); break;
                    case 'bars_wave': this.drawBarsWave(); break;
                    case 'bars_stacked': this.drawBarsStacked(); break;
                    case 'circle': this.drawCircle(); break;
                    case 'waveform': this.drawWaveform(); break;
                    case 'particles': this.drawParticles(); break;
                    case 'spiral': this.drawSpiral(); break;
                }
                
                this.ctx.restore();
            }
            
            drawDefaultAnimation() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const time = Date.now() * 0.005;
                const radius = 50 + Math.sin(time) * 20;
                
                this.ctx.strokeStyle = this.getColor(time * 10, 360, 0.8);
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                this.ctx.stroke();
                
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                this.ctx.font = '20px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Loading audio data...', centerX, centerY + 100);
            }
            
            drawBars() {
                const barWidth = this.canvas.width / this.dataArray.length;
                let x = 0;
                
                for (let i = 0; i < this.dataArray.length; i++) {
                    const barHeight = (this.dataArray[i] / 255) * this.canvas.height * 0.8 * this.sensitivity;
                    const intensity = this.dataArray[i] / 255;
                    
                    this.ctx.fillStyle = this.getColor(i, this.dataArray.length, intensity);
                    this.ctx.fillRect(x, this.canvas.height - barHeight, barWidth - 2, barHeight);
                    
                    // Top reflection
                    this.ctx.fillStyle = this.getColor(i, this.dataArray.length, intensity * 0.3);
                    this.ctx.fillRect(x, 0, barWidth - 2, barHeight * 0.5);
                    
                    x += barWidth;
                }
            }
            
            drawBarsMirror() {
                const barWidth = this.canvas.width / this.dataArray.length;
                let x = 0;
                
                for (let i = 0; i < this.dataArray.length; i++) {
                    const barHeight = (this.dataArray[i] / 255) * this.canvas.height * 0.4 * this.sensitivity;
                    const centerY = this.canvas.height / 2;
                    const intensity = this.dataArray[i] / 255;
                    
                    const color = this.getColor(i, this.dataArray.length, intensity);
                    this.ctx.fillStyle = color;
                    
                    // Bottom bars
                    this.ctx.fillRect(x, centerY, barWidth - 2, barHeight);
                    // Top bars (mirrored)
                    this.ctx.fillRect(x, centerY - barHeight, barWidth - 2, barHeight);
                    
                    // Add glow effect for mirror bars
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = color;
                    this.ctx.fillRect(x, centerY - barHeight, barWidth - 2, barHeight);
                    this.ctx.fillRect(x, centerY, barWidth - 2, barHeight);
                    this.ctx.shadowBlur = 0;
                    
                    x += barWidth;
                }
            }
            
            drawBarsCenter() {
                const barWidth = this.canvas.width / this.dataArray.length;
                const centerX = this.canvas.width / 2;
                
                for (let i = 0; i < this.dataArray.length; i++) {
                    const barHeight = (this.dataArray[i] / 255) * this.canvas.height * 0.8 * this.sensitivity;
                    const intensity = this.dataArray[i] / 255;
                    
                    this.ctx.fillStyle = this.getColor(i, this.dataArray.length, intensity);
                    
                    const leftX = centerX - (i + 1) * barWidth;
                    if (leftX >= 0) {
                        this.ctx.fillRect(leftX, this.canvas.height - barHeight, barWidth - 2, barHeight);
                    }
                    
                    const rightX = centerX + i * barWidth;
                    if (rightX < this.canvas.width) {
                        this.ctx.fillRect(rightX, this.canvas.height - barHeight, barWidth - 2, barHeight);
                    }
                }
            }
            
            drawBarsRadial() {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const baseRadius = 80;
                
                for (let i = 0; i < this.dataArray.length; i++) {
                    const angle = (i / this.dataArray.length) * Math.PI * 2;
                    const barLength = (this.dataArray[i] / 255) * 200 * this.sensitivity;
                    const intensity = this.dataArray[i] / 255;
                    
                    const x1 = centerX + Math.cos(angle) * baseRadius;
                    const y1 = centerY + Math.sin(angle) * baseRadius;
                    const x2 = centerX + Math.cos(angle) * (baseRadius + barLength);
                    const y2 = centerY + Math.sin(angle) * (baseRadius + barLength);
                    
                    const color = this.getColor(i, this.dataArray.length, intensity);
                    const gradient = this.ctx.createLinearGradient(x1, y1, x2, y2);
                    gradient.addColorStop(0, color);
                    gradient.addColorStop(1, color.replace(')', ', 0.1)').replace('rgb', 'rgba'));
                    
                    this.ctx.strokeStyle = gradient;
                    this.ctx.lineWidth = 4;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, y1);
                    this.ctx.lineTo(x2, y2);
                    this.ctx.stroke();
                }
            }
            
            drawBarsWave() {
                const barWidth = this.canvas.width / this.dataArray.length;
                let x = 0;
                const time = Date.now() * 0.002;
                
                for (let i = 0; i < this.dataArray.length; i++) {
                    const baseHeight = (this.dataArray[i] / 255) * this.canvas.height * 0.6 * this.sensitivity;
                    const wave = Math.sin(time + i * 0.1) * 20;
                    const barHeight = baseHeight + wave
