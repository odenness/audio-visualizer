<!--
================================================================================
AUDIO VISUALIZER FOR YOUTUBE - Enhanced Version
================================================================================

FUNCTIONALITY SUMMARY:
This is a comprehensive web-based audio visualizer designed for creating engaging 
YouTube content. It provides real-time audio analysis and visualization with 
extensive customization options.

KEY FEATURES:
‚Ä¢ Multi-format audio support (MP3, WAV, OGG, M4A)
‚Ä¢ 10+ visualization modes (bars, circular, particles, spiral, etc.)
‚Ä¢ Flexible aspect ratio support (16:9, 21:9, 4:3, 1:1, 9:16, custom)
‚Ä¢ Advanced color schemes (rainbow, gradient, custom, monochrome)
‚Ä¢ Background image overlay with opacity/scaling controls
‚Ä¢ Real-time audio analysis using Web Audio API
‚Ä¢ Responsive design with fullscreen support
‚Ä¢ Perfect for screen recording and content creation

VISUALIZATION MODES:
‚Ä¢ Classic Bars - Traditional frequency bars
‚Ä¢ Mirror Bars - Symmetric bars with glow effects
‚Ä¢ Center Bars - Bars expanding from center
‚Ä¢ Radial Bars - Circular frequency display
‚Ä¢ Wave Bars - Animated wave motion
‚Ä¢ Stacked Bars - Multi-layered segments
‚Ä¢ Circular - Circular waveform
‚Ä¢ Waveform - Traditional oscilloscope view
‚Ä¢ Particles - Dynamic particle system
‚Ä¢ Spiral - Spiral frequency pattern

TECHNICAL ARCHITECTURE:
‚Ä¢ HTML5 Canvas for high-performance rendering
‚Ä¢ Web Audio API for real-time frequency analysis
‚Ä¢ CSS3 for modern UI styling
‚Ä¢ Vanilla JavaScript (no external dependencies)
‚Ä¢ Responsive design with aspect ratio controls

USAGE:
1. Upload audio file using file input
2. Customize visualization settings in control panels
3. Click Play to start visualization
4. Use screen recording software to capture output
5. Perfect dimensions for YouTube content creation

Created for content creators who need professional audio visualizations
for their YouTube videos, podcasts, and social media content.
================================================================================
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Visualizer for YouTube - Enhanced</title>
    
    <!-- External CSS file for all styling -->
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!-- 
    ================================================================================
    HTML STRUCTURE SECTION
    ================================================================================
    Main application layout with:
    - Full-screen visualizer container
    - Canvas element for rendering
    - Control panels for user interaction
    - Audio element for playback
    ================================================================================
    -->
    
    <!-- Main visualizer container -->
    <div id="visualizer">
        <!-- Canvas for audio visualization rendering -->
        <canvas id="canvas"></canvas>
        
        <!-- Control panels for user interaction -->
        <div class="controls">
            <!-- ===== AUDIO FILE LOADING AND PLAYBACK CONTROLS ===== -->
            <div class="control-group">
                <h4>üìÅ Audio Controls</h4>
                <!-- File input for audio upload - accepts multiple audio formats -->
                <input type="file" id="audioFile" accept="audio/*,.mp3,.wav,.ogg,.m4a">
                <!-- Playback control buttons - disabled until audio is loaded -->
                <button id="playBtn" disabled>Play</button>
                <button id="pauseBtn" disabled>Pause</button>
            </div>
            
            <!-- ===== VISUALIZATION MODE SELECTION ===== -->
            <div class="control-group">
                <h4>üé® Visualization</h4>
                <label>Mode:</label>
                <!-- Dropdown for selecting visualization type -->
                <select id="visualMode">
                    <option value="bars">Classic Bars</option>
                    <option value="bars_mirror">Mirror Bars ‚≠ê</option> <!-- Default/recommended -->
                    <option value="bars_center">Center Bars</option>
                    <option value="bars_radial">Radial Bars</option>
                    <option value="bars_wave">Wave Bars</option>
                    <option value="bars_stacked">Stacked Bars</option>
                    <option value="circle">Circular</option>
                    <option value="waveform">Waveform</option>
                    <option value="particles">Particles</option>
                    <option value="spiral">Spiral</option>
                </select>
            </div>

            <!-- ===== COLOR SCHEME AND STYLING CONTROLS ===== -->
            <div class="control-group">
                <h4>üé® Color Scheme</h4>
                <label>Color Mode:</label>
                <!-- Color mode selection dropdown -->
                <select id="colorMode">
                    <option value="rainbow">Rainbow Spectrum</option>
                    <option value="custom">Custom Colors</option>
                    <option value="gradient">Two-Color Gradient</option>
                    <option value="monochrome">Monochrome</option>
                </select>
                
                <!-- Custom color picker section - hidden by default -->
                <div id="customColors" style="display: none;">
                    <label>Primary:</label>
                    <input type="color" id="color1" value="#ff6b6b">
                    <label>Secondary:</label>
                    <input type="color" id="color2" value="#4ecdc4">
                    <label>Accent:</label>
                    <input type="color" id="color3" value="#45b7d1">
                </div>

                <!-- Quick color preset buttons -->
                <div class="color-preset">
                    <button class="preset-btn" onclick="setColorPreset('neon')">Neon</button>
                    <button class="preset-btn" onclick="setColorPreset('ocean')">Ocean</button>
                    <button class="preset-btn" onclick="setColorPreset('sunset')">Sunset</button>
                    <button class="preset-btn" onclick="setColorPreset('cyberpunk')">Cyber</button>
                </div>
            </div>

            <!-- ===== SIZE, SCALE, AND SENSITIVITY CONTROLS ===== -->
            <div class="control-group">
                <h4>üìè Size & Scale</h4>
                <!-- Overall visualizer scaling -->
                <div class="slider-group">
                    <label>Visualizer Scale:</label>
                    <input type="range" id="visualizerScale" min="0.3" max="2" step="0.1" value="1">
                    <span id="scaleValue">1.0x</span>
                </div>
                
                <!-- Audio sensitivity/responsiveness -->
                <div class="slider-group">
                    <label>Bar Sensitivity:</label>
                    <input type="range" id="sensitivity" min="0.5" max="3" step="0.1" value="1">
                    <span id="sensitivityValue">1.0x</span>
                </div>
                
                <!-- Bar width/thickness control -->
                <div class="slider-group">
                    <label>Bar Thickness:</label>
                    <input type="range" id="barThickness" min="0.2" max="3" step="0.1" value="1">
                    <span id="thicknessValue">1.0x</span>
                </div>
                
                <!-- Number of frequency bars to display -->
                <div class="slider-group">
                    <label>Bar Count:</label>
                    <input type="range" id="barCount" min="32" max="512" step="16" value="256">
                    <span id="barCountValue">256</span>
                </div>
            </div>
            
            <!-- ===== ASPECT RATIO AND RESOLUTION CONTROLS ===== -->
            <div class="control-group">
                <h4>üì∫ Aspect Ratio</h4>
                <!-- Aspect ratio selection for different content types -->
                <select id="aspectRatio">
                    <option value="fullscreen">Fullscreen</option>
                    <option value="16:9">16:9 (1920x1080)</option> <!-- Standard YouTube -->
                    <option value="21:9">21:9 (Ultrawide)</option>
                    <option value="4:3">4:3 (Classic)</option>
                    <option value="1:1">1:1 (Square)</option> <!-- Instagram -->
                    <option value="9:16">9:16 (Vertical/Mobile)</option> <!-- TikTok, Stories -->
                    <option value="custom">Custom</option>
                </select>
                
                <!-- Custom dimension inputs - shown only when custom is selected -->
                <div id="customAspect" style="display: none; margin-top: 10px;">
                    <div class="slider-group">
                        <label>Width:</label>
                        <input type="number" id="customWidth" value="1920" min="320" max="3840" style="width: 80px; padding: 5px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.3); border-radius: 3px;">
                        <label style="margin-left: 10px;">Height:</label>
                        <input type="number" id="customHeight" value="1080" min="240" max="2160" style="width: 80px; padding: 5px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.3); border-radius: 3px;">
                    </div>
                </div>
                
                <!-- Current resolution display -->
                <div style="margin-top: 10px; font-size: 11px; color: rgba(255,255,255,0.7);">
                    Current: <span id="currentResolution">Fullscreen</span>
                </div>
            </div>
            
            <!-- ===== BACKGROUND IMAGE CONTROLS ===== -->
            <div class="control-group">
                <h4>üñºÔ∏è Background</h4>
                <!-- Background image file input -->
                <input type="file" id="backgroundImage" accept="image/*" style="font-size: 12px; padding: 5px;">
                <button id="clearBg">Clear BG</button>
                
                <!-- Background opacity control -->
                <div class="slider-group">
                    <label>BG Opacity:</label>
                    <input type="range" id="bgOpacity" min="0.1" max="1" step="0.1" value="0.7">
                    <span id="opacityValue">0.7</span>
                </div>
                
                <!-- Background scaling control -->
                <div class="slider-group">
                    <label>BG Scale:</label>
                    <input type="range" id="bgScale" min="0.5" max="2" step="0.1" value="1">
                    <span id="bgScaleValue">1.0x</span>
                </div>
            </div>
        </div>

        <!-- ===== INFORMATION DISPLAY PANEL ===== -->
        <!-- Bottom-right info panel with usage instructions and status -->
        <div class="info">
            <div>Upload an audio file to start visualizing</div>
            <div>Supported formats: MP3, WAV, OGG, M4A</div>
            <div>Perfect for screen recording for YouTube videos</div>
        </div>
    </div>

    <!-- Hidden audio element for playback -->
    <audio id="audio" style="display: none;"></audio>

    <!-- External JavaScript file for all functionality -->
    <script src="script.js"></script>
</body>
</html>
            background: rgba(255,255,255,0.2);
            transform: none; /* No lift effect for preset buttons */
            box-shadow: none;
        }

        /* ===== INFO PANEL STYLING ===== */
        /* Bottom-right information display */
        .info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: rgba(255,255,255,0.7);
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }

        /* ===== SLIDER GROUP LAYOUT ===== */
        /* Horizontal layout for slider controls with labels and values */
        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }

        /* Value display spans for sliders */
        .slider-group span {
            color: white;
            font-size: 11px;
            min-width: 30px; /* Consistent width for alignment */
        }
    </style>
</head>
<body>
    <!-- 
    ================================================================================
    HTML STRUCTURE SECTION
    ================================================================================
    Main application layout with:
    - Full-screen visualizer container
    - Canvas element for rendering
    - Control panels for user interaction
    - Audio element for playback
    ================================================================================
    -->
    
    <!-- Main visualizer container -->
    <div id="visualizer">
        <!-- Canvas for audio visualization rendering -->
        <canvas id="canvas"></canvas>
        
        <!-- Control panels for user interaction -->
        <div class="controls">
            <!-- ===== AUDIO FILE LOADING AND PLAYBACK CONTROLS ===== -->
            <div class="control-group">
                <h4>üìÅ Audio Controls</h4>
                <!-- File input for audio upload - accepts multiple audio formats -->
                <input type="file" id="audioFile" accept="audio/*,.mp3,.wav,.ogg,.m4a">
                <!-- Playback control buttons - disabled until audio is loaded -->
                <button id="playBtn" disabled>Play</button>
                <button id="pauseBtn" disabled>Pause</button>
            </div>
            
            <!-- ===== VISUALIZATION MODE SELECTION ===== -->
            <div class="control-group">
                <h4>üé® Visualization</h4>
                <label>Mode:</label>
                <!-- Dropdown for selecting visualization type -->
                <select id="visualMode">
                    <option value="bars">Classic Bars</option>
                    <option value="bars_mirror">Mirror Bars ‚≠ê</option> <!-- Default/recommended -->
                    <option value="bars_center">Center Bars</option>
                    <option value="bars_radial">Radial Bars</option>
                    <option value="bars_wave">Wave Bars</option>
                    <option value="bars_stacked">Stacked Bars</option>
                    <option value="circle">Circular</option>
                    <option value="waveform">Waveform</option>
                    <option value="particles">Particles</option>
                    <option value="spiral">Spiral</option>
                </select>
            </div>

            <!-- ===== COLOR SCHEME AND STYLING CONTROLS ===== -->
            <div class="control-group">
                <h4>üé® Color Scheme</h4>
                <label>Color Mode:</label>
                <!-- Color mode selection dropdown -->
                <select id="colorMode">
                    <option value="rainbow">Rainbow Spectrum</option>
                    <option value="custom">Custom Colors</option>
                    <option value="gradient">Two-Color Gradient</option>
                    <option value="monochrome">Monochrome</option>
                </select>
                
                <!-- Custom color picker section - hidden by default -->
                <div id="customColors" style="display: none;">
                    <label>Primary:</label>
                    <input type="color" id="color1" value="#ff6b6b">
                    <label>Secondary:</label>
                    <input type="color" id="color2" value="#4ecdc4">
                    <label>Accent:</label>
                    <input type="color" id="color3" value="#45b7d1">
                </div>

                <!-- Quick color preset buttons -->
                <div class="color-preset">
                    <button class="preset-btn" onclick="setColorPreset('neon')">Neon</button>
                    <button class="preset-btn" onclick="setColorPreset('ocean')">Ocean</button>
                    <button class="preset-btn" onclick="setColorPreset('sunset')">Sunset</button>
                    <button class="preset-btn" onclick="setColorPreset('cyberpunk')">Cyber</button>
                </div>
            </div>

            <!-- ===== SIZE, SCALE, AND SENSITIVITY CONTROLS ===== -->
            <div class="control-group">
                <h4>üìè Size & Scale</h4>
                <!-- Overall visualizer scaling -->
                <div class="slider-group">
                    <label>Visualizer Scale:</label>
                    <input type="range" id="visualizerScale" min="0.3" max="2" step="0.1" value="1">
                    <span id="scaleValue">1.0x</span>
                </div>
                
                <!-- Audio sensitivity/responsiveness -->
                <div class="slider-group">
                    <label>Bar Sensitivity:</label>
                    <input type="range" id="sensitivity" min="0.5" max="3" step="0.1" value="1">
                    <span id="sensitivityValue">1.0x</span>
                </div>
                
                <!-- Bar width/thickness control -->
                <div class="slider-group">
                    <label>Bar Thickness:</label>
                    <input type="range" id="barThickness" min="0.2" max="3" step="0.1" value="1">
                    <span id="thicknessValue">1.0x</span>
                </div>
                
                <!-- Number of frequency bars to display -->
                <div class="slider-group">
                    <label>Bar Count:</label>
                    <input type="range" id="barCount" min="32" max="512" step="16" value="256">
                    <span id="barCountValue">256</span>
                </div>
            </div>
            
            <!-- ===== ASPECT RATIO AND RESOLUTION CONTROLS ===== -->
            <div class="control-group">
                <h4>üì∫ Aspect Ratio</h4>
                <!-- Aspect ratio selection for different content types -->
                <select id="aspectRatio">
                    <option value="fullscreen">Fullscreen</option>
                    <option value="16:9">16:9 (1920x1080)</option> <!-- Standard YouTube -->
                    <option value="21:9">21:9 (Ultrawide)</option>
                    <option value="4:3">4:3 (Classic)</option>
                    <option value="1:1">1:1 (Square)</option> <!-- Instagram -->
                    <option value="9:16">9:16 (Vertical/Mobile)</option> <!-- TikTok, Stories -->
                    <option value="custom">Custom</option>
                </select>
                
                <!-- Custom dimension inputs - shown only when custom is selected -->
                <div id="customAspect" style="display: none; margin-top: 10px;">
                    <div class="slider-group">
                        <label>Width:</label>
                        <input type="number" id="customWidth" value="1920" min="320" max="3840" style="width: 80px; padding: 5px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.3); border-radius: 3px;">
                        <label style="margin-left: 10px;">Height:</label>
                        <input type="number" id="customHeight" value="1080" min="240" max="2160" style="width: 80px; padding: 5px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.3); border-radius: 3px;">
                    </div>
                </div>
                
                <!-- Current resolution display -->
                <div style="margin-top: 10px; font-size: 11px; color: rgba(255,255,255,0.7);">
                    Current: <span id="currentResolution">Fullscreen</span>
                </div>
            </div>
            
            <!-- ===== BACKGROUND IMAGE CONTROLS ===== -->
            <div class="control-group">
                <h4>üñºÔ∏è Background</h4>
                <!-- Background image file input -->
                <input type="file" id="backgroundImage" accept="image/*" style="font-size: 12px; padding: 5px;">
                <button id="clearBg">Clear BG</button>
                
                <!-- Background opacity control -->
                <div class="slider-group">
                    <label>BG Opacity:</label>
                    <input type="range" id="bgOpacity" min="0.1" max="1" step="0.1" value="0.7">
                    <span id="opacityValue">0.7</span>
                </div>
                
                <!-- Background scaling control -->
                <div class="slider-group">
                    <label>BG Scale:</label>
                    <input type="range" id="bgScale" min="0.5" max="2" step="0.1" value="1">
                    <span id="bgScaleValue">1.0x</span>
                </div>
            </div>
        </div>

        <!-- ===== INFORMATION DISPLAY PANEL ===== -->
        <!-- Bottom-right info panel with usage instructions and status -->
        <div class="info">
            <div>Upload an audio file to start visualizing</div>
            <div>Supported formats: MP3, WAV, OGG, M4A</div>
            <div>Perfect for screen recording for YouTube videos</div>
        </div>
    </div>

    <!-- Hidden audio element for playback -->
    <audio id="audio" style="display: none;"></audio>

    <!-- 
    ================================================================================
    JAVASCRIPT APPLICATION CODE
    ================================================================================
    Main AudioVisualizer class and supporting functions for:
    - Audio file processing and Web Audio API integration
    - Real-time frequency analysis and visualization
    - User interface event handling
    - Canvas rendering with multiple visualization modes
    - Color management and visual effects
    ================================================================================
    -->
    <script>
        /**
         * ============================================================================
         * AUDIO VISUALIZER CLASS
         * ============================================================================
         * Main class that handles all audio visualization functionality including
         * audio processing, canvas rendering, user controls, and visual effects.
         * ============================================================================
         */
        class AudioVisualizer {
            /**
             * Constructor - Initializes the AudioVisualizer instance
             * Sets up canvas, audio context, default settings, and event listeners
             */
            constructor() {
                // ===== CANVAS AND RENDERING SETUP =====
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                
                // ===== AUDIO ELEMENTS AND WEB AUDIO API COMPONENTS =====
                this.audio = document.getElementById('audio');
                this.audioContext = null;        // Web Audio API context
                this.analyser = null;            // Audio analyser node
                this.dataArray = null;           // Frequency data array
                this.source = null;              // Audio source node
                this.animationId = null;         // Animation frame ID
                this.currentFileName = '';       // Current audio file name
                
                // ===== BACKGROUND IMAGE HANDLING =====
                this.backgroundImage = null;     // Background image object
                
                // ===== PARTICLE SYSTEM FOR PARTICLE VISUALIZATION MODE =====
                this.particles = [];             // Array of particle objects
                
                // ===== VISUALIZATION SETTINGS WITH DEFAULT VALUES =====
                this.visualMode = 'bars_mirror';  // Default to mirror bars (recommended)
                this.colorMode = 'rainbow';       // Default color scheme
                this.customColors = ['#ff6b6b', '#4ecdc4', '#45b7d1']; // Custom color palette
                this.visualizerScale = 1;         // Overall scale multiplier
                this.sensitivity = 1;             // Audio sensitivity multiplier
                this.bgOpacity = 0.7;            // Background image opacity
                this.bgScale = 1;                // Background image scale
                this.barThickness = 1;           // Bar thickness multiplier
                this.barCount = 256;             // Number of frequency bars
                this.aspectRatio = 'fullscreen'; // Display aspect ratio
                
                // ===== CANVAS DIMENSIONS =====
                this.canvasWidth = window.innerWidth;
                this.canvasHeight = window.innerHeight;
                
                // ===== INITIALIZE COMPONENTS =====
                this.setupCanvas();           // Configure canvas and resize handling
                this.setupEventListeners();   // Bind UI event handlers
                this.setupParticles();        // Initialize particle system
            }
            
            /**
             * ========================================================================
             * CANVAS SETUP AND SIZING
             * ========================================================================
             */
            
            /**
             * Sets up canvas sizing and window resize handling
             * Configures initial canvas dimensions and responsive behavior
             */
            setupCanvas() {
                this.updateCanvasSize();
                
                // Handle window resize for fullscreen mode
                window.addEventListener('resize', () => {
                    if (this.aspectRatio === 'fullscreen') {
                        this.updateCanvasSize();
                    }
                });
            }
            
            /**
             * Updates canvas dimensions based on selected aspect ratio
             * Handles multiple aspect ratios including custom dimensions
             * Updates resolution display and canvas styling
             */
            updateCanvasSize() {
                // Calculate dimensions based on aspect ratio selection
                switch (this.aspectRatio) {
                    case 'fullscreen':
                        this.canvasWidth = window.innerWidth;
                        this.canvasHeight = window.innerHeight;
                        break;
                    case '16:9': // Standard YouTube format
                        const width16_9 = Math.min(window.innerWidth, window.innerHeight * (16/9));
                        this.canvasWidth = width16_9;
                        this.canvasHeight = width16_9 * (9/16);
                        break;
                    case '21:9': // Ultrawide format
                        const width21_9 = Math.min(window.innerWidth, window.innerHeight * (21/9));
                        this.canvasWidth = width21_9;
                        this.canvasHeight = width21_9 * (9/21);
                        break;
                    case '4:3': // Classic TV format
                        const width4_3 = Math.min(window.innerWidth, window.innerHeight * (4/3));
                        this.canvasWidth = width4_3;
                        this.canvasHeight = width4_3 * (3/4);
                        break;
                    case '1:1': // Square format (Instagram)
                        const size1_1 = Math.min(window.innerWidth, window.innerHeight);
                        this.canvasWidth = size1_1;
                        this.canvasHeight = size1_1;
                        break;
                    case '9:16': // Vertical format (TikTok, Stories)
                        const height9_16 = Math.min(window.innerHeight, window.innerWidth * (16/9));
                        this.canvasHeight = height9_16;
                        this.canvasWidth = height9_16 * (9/16);
                        break;
                    case 'custom': // User-defined dimensions
                        this.canvasWidth = parseInt(document.getElementById('customWidth').value) || 1920;
                        this.canvasHeight = parseInt(document.getElementById('customHeight').value) || 1080;
                        // Scale down if larger than window
                        const scale = Math.min(window.innerWidth / this.canvasWidth, window.innerHeight / this.canvasHeight);
                        if (scale < 1) {
                            this.canvasWidth *= scale;
                            this.canvasHeight *= scale;
                        }
                        break;
                }
                
                // Apply dimensions to canvas element
                this.canvas.width = this.canvasWidth;
                this.canvas.height = this.canvasHeight;
                
                // Center canvas and apply styling
                this.canvas.style.position = 'absolute';
                this.canvas.style.left = '50%';
                this.canvas.style.top = '50%';
                this.canvas.style.transform = 'translate(-50%, -50%)';
                this.canvas.style.border = this.aspectRatio !== 'fullscreen' ? '2px solid rgba(255,255,255,0.3)' : 'none';
                
                // Update resolution display in UI
                document.getElementById('currentResolution').textContent = `${Math.round(this.canvasWidth)} √ó ${Math.round(this.canvasHeight)}`;
            }
            
            /**
             * ========================================================================
             * USER INTERFACE EVENT HANDLING
             * ========================================================================
             */
            
            /**
             * Sets up all user interface event listeners
             * Handles file uploads, playback controls, visualization settings,
             * color controls, scaling options, and background management
             */
            setupEventListeners() {
                // ===== GET DOM ELEMENTS FOR EVENT BINDING =====
                const fileInput = document.getElementById('audioFile');
                const playBtn = document.getElementById('playBtn');
                const pauseBtn = document.getElementById('pauseBtn');
                const visualMode = document.getElementById('visualMode');
                const colorMode = document.getElementById('colorMode');
                const backgroundInput = document.getElementById('backgroundImage');
                const clearBgBtn = document.getElementById('clearBg');
                
                // ===== AUDIO FILE SELECTION HANDLER =====
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.currentFileName = file.name;
                        this.loadAudio(file);
                    }
                });
                
                // ===== PLAYBACK CONTROL HANDLERS =====
                playBtn.addEventListener('click', () => this.play());
                pauseBtn.addEventListener('click', () => this.pause());
                
                // ===== VISUALIZATION MODE CHANGE HANDLER =====
                visualMode.addEventListener('change', (e) => {
                    this.visualMode = e.target.value;
                    // Reinitialize particles if switching to particle mode
                    if (this.visualMode === 'particles') {
                        this.setupParticles();
                    }
                });
                
                // ===== COLOR MODE CHANGE HANDLER =====
                colorMode.addEventListener('change', (e) => {
                    this.colorMode = e.target.value;
                    const customDiv = document.getElementById('customColors');
                    // Show/hide custom color controls based on mode
                    customDiv.style.display = e.target.value === 'custom' || e.target.value === 'gradient' ? 'block' : 'none';
                });
                
                // ===== CUSTOM COLOR INPUT HANDLERS =====
                document.getElementById('color1').addEventListener('change', (e) => {
                    this.customColors[0] = e.target.value;
                });
                document.getElementById('color2').addEventListener('change', (e) => {
                    this.customColors[1] = e.target.value;
                });
                document.getElementById('color3').addEventListener('change', (e) => {
                    this.customColors[2] = e.target.value;
                });
                
                // ===== SCALE AND SENSITIVITY CONTROL HANDLERS WITH LIVE VALUE DISPLAY =====
                document.getElementById('visualizerScale').addEventListener('input', (e) => {
                    this.visualizerScale = parseFloat(e.target.value);
                    document.getElementById('scaleValue').textContent = this.visualizerScale.toFixed(1) + 'x';
                });
                
                document.getElementById('sensitivity').addEventListener('input', (e) => {
                    this.sensitivity = parseFloat(e.target.value);
                    document.getElementById('sensitivityValue').textContent = this.sensitivity.toFixed(1) + 'x';
                });
                
                document.getElementById('barThickness').addEventListener('input', (e) => {
                    this.barThickness = parseFloat(e.target.value);
                    document.getElementById('thicknessValue').textContent = this.barThickness.toFixed(1) + 'x';
                });
                
                document.getElementById('barCount').addEventListener('input', (e) => {
                    this.barCount = parseInt(e.target.value);
                    document.getElementById('barCountValue').textContent = this.barCount;
                });
                
                // ===== ASPECT RATIO CONTROL HANDLERS =====
                document.getElementById('aspectRatio').addEventListener('change', (e) => {
                    this.aspectRatio = e.target.value;
                    const customDiv = document.getElementById('customAspect');
                    customDiv.style.display = e.target.value === 'custom' ? 'block' : 'none';
                    this.updateCanvasSize();
                });
                
                // ===== CUSTOM DIMENSION INPUT HANDLERS =====
                document.getElementById('customWidth').addEventListener('input', () => {
                    if (this.aspectRatio === 'custom') {
                        this.updateCanvasSize();
                    }
                });
                
                document.getElementById('customHeight').addEventListener('input', () => {
                    if (this.aspectRatio === 'custom') {
                        this.updateCanvasSize();
                    }
                });
                
                // ===== BACKGROUND IMAGE CONTROL HANDLERS =====
                backgroundInput.addEventListener('change', (e) => this.loadBackground(e));
                clearBgBtn.addEventListener('click', () => this.clearBackground());
                
                // ===== BACKGROUND OPACITY AND SCALE CONTROL HANDLERS =====
                document.getElementById('bgOpacity').addEventListener('input', (e) => {
                    this.bgOpacity = parseFloat(e.target.value);
                    document.getElementById('opacityValue').textContent = this.bgOpacity.toFixed(1);
                });
                
                document.getElementById('bgScale').addEventListener('input', (e) => {
                    this.bgScale = parseFloat(e.target.value);
                    document.getElementById('bgScaleValue').textContent = this.bgScale.toFixed(1) + 'x';
                });
            }
            
            /**
             * ========================================================================
             * PARTICLE SYSTEM INITIALIZATION
             * ========================================================================
             */
            
            /**
             * Initializes particle system for particle visualization mode
             * Creates array of particle objects with random positions and velocities
             * Particle count scales with visualizer scale setting
             */
            setupParticles() {
                this.particles = [];
                const particleCount = Math.floor(100 * this.visualizerScale);
                
                // Create particles with random properties
                for (let i = 0; i < particleCount; i++) {
                    this.particles.push({
                        x: Math.random() * this.canvasWidth,      // Random X position
                        y: Math.random() * this.canvasHeight,     // Random Y position
                        vx: (Math.random() - 0.5) * 2,           // X velocity
                        vy: (Math.random() - 0.5) * 2,           // Y velocity
                        size: Math.random() * 3 + 1,             // Particle size
                        hue: Math.random() * 360                 // Color hue
                    });
                }
            }
            
            /**
             * ========================================================================
             * BACKGROUND IMAGE MANAGEMENT
             * ========================================================================
             */
            
            /**
             * Loads and processes background image file
             * @param {Event} event - File input change event
             * Handles image loading with error checking and validation
             */
            loadBackground(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const img = new Image();
                
                // Success handler - store loaded image
                img.onload = () => {
                    this.backgroundImage = img;
                    console.log('Background image loaded');
                };
                
                // Error handler - show user feedback
                img.onerror = () => {
                    console.error('Failed to load background image');
                    alert('Failed to load background image. Please try a different file.');
                };
                
                // Load image from file
                img.src = URL.createObjectURL(file);
            }
            
            /**
             * Clears the current background image
             * Resets background image and file input
             */
            clearBackground() {
                this.backgroundImage = null;
                document.getElementById('backgroundImage').value = '';
                console.log('Background cleared');
            }
            
            /**
             * ========================================================================
             * COLOR MANAGEMENT SYSTEM
             * ========================================================================
             */
            
            /**
             * Generates colors based on current color mode and settings
             * @param {number} index - Current item index for color calculation
             * @param {number} total - Total number of items
             * @param {number} intensity - Audio intensity (0-1) for brightness
             * @returns {string} CSS color string
             */
            getColor(index, total, intensity = 1) {
                switch (this.colorMode) {
                    case 'rainbow':
                        // HSL rainbow spectrum based on index position
                        const hue = (index / total) * 360;
                        const saturation = 70 + (intensity * 30);
                        const lightness = 50 + (intensity * 30);
                        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    
                    case 'custom':
                        // Use predefined custom colors
                        const colorIndex = Math.floor((index / total) * this.customColors.length);
                        return this.customColors[colorIndex] || this.customColors[0];
                    
                    case 'gradient':
                        // Linear interpolation between two custom colors
                        const ratio = index / total;
                        const color1 = this.hexToRgb(this.customColors[0]);
                        const color2 = this.hexToRgb(this.customColors[1]);
                        const r = Math.floor(color1.r + (color2.r - color1.r) * ratio);
                        const g = Math.floor(color1.g + (color2.g - color1.g) * ratio);
                        const b = Math.floor(color1.b + (color2.b - color1.b) * ratio);
                        return `rgba(${r}, ${g}, ${b}, ${intensity})`;
                    
                    case 'monochrome':
                        // Single hue with varying brightness
                        const brightness = 50 + (intensity * 50);
                        return `hsl(220, 30%, ${brightness}%)`;
                    
                    default:
                        return `hsl(${(index / total) * 360}, 80%, 60%)`;
                }
            }
            
            /**
             * Converts hex color string to RGB object
             * @param {string} hex - Hex color string (e.g., "#ff0000")
             * @returns {Object} RGB object with r, g, b properties
             */
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : {r: 255, g: 107, b: 107}; // Default red if parsing fails
            }
            
            /**
             * ========================================================================
             * AUDIO LOADING AND PROCESSING
             * ========================================================================
             */
            
            /**
             * Loads audio file and sets up audio element
             * @param {File} file - Audio file to load
             * Handles multiple audio formats with error fallback
             */
            loadAudio(file) {
                console.log('Loading file:', file.name, 'Type:', file.type, 'Size:', file.size);
                
                // Create object URL for audio element
                const url = URL.createObjectURL(file);
                this.audio.src = url;
                
                // Success handler - enable controls and update UI
                this.audio.addEventListener('loadedmetadata', () => {
                    console.log('Audio metadata loaded successfully');
                    document.getElementById('playBtn').disabled = false;
                    document.getElementById('pauseBtn').disabled = false;
                    
                    // Update info panel with file details
                    document.querySelector('.info').innerHTML = `
                        <div style="color: #00ff88;">‚úì Audio loaded: ${this.currentFileName}</div>
                        <div>Duration: ${Math.floor(this.audio.duration / 60)}:${Math.floor(this.audio.duration % 60).toString().padStart(2, '0')}</div>
                        <div>Click Play to start visualization</div>
                    `;
                });
                
                // Error handler - fall back to demo mode
                this.audio.addEventListener('error', (e) => {
                    console.error('Audio loading error:', e);
                    this.startDemoVisualization();
                    document.querySelector('.info').innerHTML = `
                        <div style="color: #ff6b6b;">‚ö† Audio format issue - showing demo</div>
                        <div>Try converting to standard MP3 format</div>
                        <div>Demo visualization running</div>
                    `;
                });
            }
            
            /**
             * ========================================================================
             * AUDIO PLAYBACK AND WEB AUDIO API SETUP
             * ========================================================================
             */
            
            /**
             * Starts audio playback and visualization
             * Sets up Web Audio API components for frequency analysis
             * Handles audio context initialization and connection
             */
            async play() {
                try {
                    // Initialize Web Audio API components on first play
                    if (!this.audioContext) {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        this.analyser = this.audioContext.createAnalyser();
                        this.analyser.fftSize = 512;                    // FFT size for frequency analysis
                        this.analyser.smoothingTimeConstant = 0.8;      // Smoothing between frames
                        this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                        
                        // Connect audio element to analyser
                        this.source = this.audioContext.createMediaElementSource(this.audio);
                        this.source.connect(this.analyser);
                        this.analyser.connect(this.audioContext.destination);
                    }
                    
                    // Resume audio context if suspended (browser autoplay policy)
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                    
                    // Start audio playback
                    await this.audio.play();
                    this.startVisualization();
                    
                } catch (error) {
                    console.error('Error playing audio:', error);
                    // Fall back to demo visualization if audio fails
                    this.startDemoVisualization();
                }
            }
            
            /**
             * Pauses audio playback and stops visualization animation
             */
            pause() {
                this.audio.pause();
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }
            
            /**
             * ========================================================================
             * VISUALIZATION ANIMATION LOOPS
             * ========================================================================
             */
            
            /**
             * Starts the main visualization animation loop
             * Continuously analyzes audio data and renders visualization
             */
            startVisualization() {
                const animate = () => {
                    // Stop animation if audio is paused
                    if (this.audio.paused) return;
                    
                    // Request next animation frame
                    this.animationId = requestAnimationFrame(animate);
                    
                    // Get frequency data and render
                    if (this.analyser && this.dataArray) {
                        this.analyser.getByteFrequencyData(this.dataArray);
                        this.draw();
                    }
                };
                animate();
            }
            
            /**
             * Starts demo visualization with synthetic audio data
             * Used when audio loading fails or for preview purposes
             * Generates sine wave patterns to simulate audio data
             */
            startDemoVisualization() {
                this.dataArray = new Uint8Array(256);
                
                const animate = () => {
                    this.animationId = requestAnimationFrame(animate);
                    
                    // Generate synthetic frequency data using sine waves
                    const time = Date.now() * 0.001;
                    for (let i = 0; i < this.dataArray.length; i++) {
                        // Combine multiple sine waves for realistic audio simulation
                        this.dataArray[i] = Math.abs(
                            Math.sin(time + i * 0.1) * 128 + 
                            Math.sin(time * 2 + i * 0.05) * 64
                        );
                    }
                    
                    this.draw();
                };
                animate();
            }
            
            /**
             * ========================================================================
             * MAIN RENDERING SYSTEM
             * ========================================================================
             */
            
            /**
             * Main rendering function - draws current frame of visualization
             * Handles background rendering, scaling, and delegates to specific draw methods
             */
            draw() {
                // ===== RENDER BACKGROUND (IMAGE OR DEFAULT) =====
                if (this.backgroundImage) {
                    // Draw background image with opacity and scaling
                    this.ctx.globalAlpha = this.bgOpacity;
                    const scaledWidth = this.canvasWidth * this.bgScale;
                    const scaledHeight = this.canvasHeight * this.bgScale;
                    const offsetX = (this.canvasWidth - scaledWidth) / 2;
                    const offsetY = (this.canvasHeight - scaledHeight) / 2;
                    this.ctx.drawImage(this.backgroundImage, offsetX, offsetY, scaledWidth, scaledHeight);
                    this.ctx.globalAlpha = 1.0;
                    // Add dark overlay for better visualization visibility
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    this.ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
                } else {
                    // Default background with fade effect
                    this.ctx.fillStyle = 'rgba(10, 10, 10, 0.2)';
                    this.ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
                }
                
                // ===== APPLY VISUALIZER SCALING TRANSFORMATION =====
                this.ctx.save();
                const centerX = this.canvasWidth / 2;
                const centerY = this.canvasHeight / 2;
                this.ctx.translate(centerX, centerY);
                this.ctx.scale(this.visualizerScale, this.visualizerScale);
                this.ctx.translate(-centerX, -centerY);
                
                // ===== HANDLE NO AUDIO DATA CASE =====
                if (!this.dataArray || this.dataArray.every(val => val === 0)) {
                    this.drawDefaultAnimation();
                    this.ctx.restore();
                    return;
                }
                
                // ===== DELEGATE TO SPECIFIC VISUALIZATION METHOD =====
                switch (this.visualMode) {
                    case 'bars': this.drawBars(); break;
                    case 'bars_mirror': this.drawBarsMirror(); break;
                    case 'bars_center': this.drawBarsCenter(); break;
                    case 'bars_radial': this.drawBarsRadial(); break;
                    case 'bars_wave': this.drawBarsWave(); break;
                    case 'bars_stacked': this.drawBarsStacked(); break;
                    case 'circle': this.drawCircle(); break;
                    case 'waveform': this.drawWaveform(); break;
                    case 'particles': this.drawParticles(); break;
                    case 'spiral': this.drawSpiral(); break;
                }
                
                this.ctx.restore();
            }
            
            /**
             * ========================================================================
             * DEFAULT LOADING ANIMATION
             * ========================================================================
             */
            
            /**
             * Draws default loading animation when no audio data is available
             * Simple pulsing circle with loading text
             */
            drawDefaultAnimation() {
                const centerX = this.canvasWidth / 2;
                const centerY = this.canvasHeight / 2;
                const time = Date.now() * 0.005;
                const radius = 50 + Math.sin(time) * 20;
                
                // Animated pulsing circle
                this.ctx.strokeStyle = this.getColor(time * 10, 360, 0.8);
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Loading text
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                this.ctx.font = '20px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Loading audio data...', centerX, centerY + 100);
            }
            
            /**
             * ========================================================================
             * DATA SAMPLING AND PROCESSING
             * ========================================================================
             */
            
            /**
             * Samples frequency data to match the desired bar count
             * @returns {Array} Sampled frequency data array
             * Handles both upsampling and downsampling of frequency data
             */
            getSampledData() {
                if (!this.dataArray) return [];
                
                // If bar count is greater than available data, return all data
                if (this.barCount >= this.dataArray.length) {
                    return Array.from(this.dataArray);
                }
                
                // Downsample by averaging frequency bins
                const sampledData = [];
                const sampleSize = this.dataArray.length / this.barCount;
                
                for (let i = 0; i < this.barCount; i++) {
                    const start = Math.floor(i * sampleSize);
                    const end = Math.floor((i + 1) * sampleSize);
                    let sum = 0;
                    let count = 0;
                    
                    // Average the frequency bins in this sample range
                    for (let j = start; j < end && j < this.dataArray.length; j++) {
                        sum += this.dataArray[j];
                        count++;
                    }
                    
                    sampledData.push(count > 0 ? sum / count : 0);
                }
                
                return sampledData;
            }
            
            /**
             * ========================================================================
             * VISUALIZATION RENDERING METHODS
             * ========================================================================
             * Each method implements a different visualization style
             */
            
            drawBars() {
                const sampledData = this.getSampledData();
                const barWidth = (this.canvasWidth / sampledData.length) * this.barThickness;
                const barSpacing = this.canvasWidth / sampledData.length;
                let x = (barSpacing - barWidth) / 2;
                
                for (let i = 0; i < sampledData.length; i++) {
                    const barHeight = (sampledData[i] / 255) * this.canvasHeight * 0.8 * this.sensitivity;
                    const intensity = sampledData[i] / 255;
                    
                    this.ctx.fillStyle = this.getColor(i, sampledData.length, intensity);
                    this.ctx.fillRect(x, this.canvasHeight - barHeight, barWidth, barHeight);
                    
                    this.ctx.fillStyle = this.getColor(i, sampledData.length, intensity * 0.3);
                    this.ctx.fillRect(x, 0, barWidth, barHeight * 0.5);
                    
                    x += barSpacing;
                }
            }
            
            drawBarsMirror() {
                const sampledData = this.getSampledData();
                const barWidth = (this.canvasWidth / sampledData.length) * this.barThickness;
                const barSpacing = this.canvasWidth / sampledData.length;
                let x = (barSpacing - barWidth) / 2;
                
                for (let i = 0; i < sampledData.length; i++) {
                    const barHeight = (sampledData[i] / 255) * this.canvasHeight * 0.4 * this.sensitivity;
                    const centerY = this.canvasHeight / 2;
                    const intensity = sampledData[i] / 255;
                    
                    const color = this.getColor(i, sampledData.length, intensity);
                    this.ctx.fillStyle = color;
                    
                    this.ctx.fillRect(x, centerY, barWidth, barHeight);
                    this.ctx.fillRect(x, centerY - barHeight, barWidth, barHeight);
                    
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowColor = color;
                    this.ctx.fillRect(x, centerY - barHeight, barWidth, barHeight);
                    this.ctx.fillRect(x, centerY, barWidth, barHeight);
                    this.ctx.shadowBlur = 0;
                    
                    x += barSpacing;
                }
            }
            
            drawBarsCenter() {
                const sampledData = this.getSampledData();
                const barWidth = (this.canvasWidth / sampledData.length) * this.barThickness;
                const barSpacing = this.canvasWidth / sampledData.length;
                const centerX = this.canvasWidth / 2;
                
                for (let i = 0; i < sampledData.length; i++) {
                    const barHeight = (sampledData[i] / 255) * this.canvasHeight * 0.8 * this.sensitivity;
                    const intensity = sampledData[i] / 255;
                    
                    this.ctx.fillStyle = this.getColor(i, sampledData.length, intensity);
                    
                    const leftX = centerX - (i + 1) * barSpacing + (barSpacing - barWidth) / 2;
                    if (leftX >= 0) {
                        this.ctx.fillRect(leftX, this.canvasHeight - barHeight, barWidth, barHeight);
                    }
                    
                    const rightX = centerX + i * barSpacing + (barSpacing - barWidth) / 2;
                    if (rightX < this.canvasWidth) {
                        this.ctx.fillRect(rightX, this.canvasHeight - barHeight, barWidth, barHeight);
                    }
                }
            }
            
            drawBarsRadial() {
                const sampledData = this.getSampledData();
                const centerX = this.canvasWidth / 2;
                const centerY = this.canvasHeight / 2;
                const baseRadius = 80;
                
                for (let i = 0; i < sampledData.length; i++) {
                    const angle = (i / sampledData.length) * Math.PI * 2;
                    const barLength = (sampledData[i] / 255) * 200 * this.sensitivity;
                    const intensity = sampledData[i] / 255;
                    
                    const x1 = centerX + Math.cos(angle) * baseRadius;
                    const y1 = centerY + Math.sin(angle) * baseRadius;
                    const x2 = centerX + Math.cos(angle) * (baseRadius + barLength);
                    const y2 = centerY + Math.sin(angle) * (baseRadius + barLength);
                    
                    const color = this.getColor(i, sampledData.length, intensity);
                    const gradient = this.ctx.createLinearGradient(x1, y1, x2, y2);
                    gradient.addColorStop(0, color);
                    gradient.addColorStop(1, color.replace(')', ', 0.1)').replace('rgb', 'rgba'));
                    
                    this.ctx.strokeStyle = gradient;
                    this.ctx.lineWidth = 4 * this.barThickness;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, y1);
                    this.ctx.lineTo(x2, y2);
                    this.ctx.stroke();
                }
            }
            
            drawBarsWave() {
                const sampledData = this.getSampledData();
                const barWidth = (this.canvasWidth / sampledData.length) * this.barThickness;
                const barSpacing = this.canvasWidth / sampledData.length;
                let x = (barSpacing - barWidth) / 2;
                const time = Date.now() * 0.002;
                
                for (let i = 0; i < sampledData.length; i++) {
                    const baseHeight = (sampledData[i] / 255) * this.canvasHeight * 0.6 * this.sensitivity;
                    const wave = Math.sin(time + i * 0.1) * 20;
                    const barHeight = baseHeight + wave;
                    const intensity = sampledData[i] / 255;
                    
                    this.ctx.fillStyle = this.getColor(i + time * 50, sampledData.length, intensity);
                    this.ctx.fillRect(x, this.canvasHeight - Math.abs(barHeight), barWidth, Math.abs(barHeight));
                    
                    x += barSpacing;
                }
            }
            
            drawBarsStacked() {
                const sampledData = this.getSampledData();
                const barWidth = (this.canvasWidth / sampledData.length) * this.barThickness;
                const barSpacing = this.canvasWidth / sampledData.length;
                let x = (barSpacing - barWidth) / 2;
                
                for (let i = 0; i < sampledData.length; i++) {
                    const totalHeight = (sampledData[i] / 255) * this.canvasHeight * 0.8 * this.sensitivity;
                    const segments = 5;
                    const segmentHeight = totalHeight / segments;
                    const intensity = sampledData[i] / 255;
                    
                    for (let j = 0; j < segments; j++) {
                        const alpha = 1 - (j * 0.15);
                        const color = this.getColor(i + j * 10, sampledData.length, intensity * alpha);
                        
                        this.ctx.fillStyle = color;
                        this.ctx.fillRect(x, this.canvasHeight - (j + 1) * segmentHeight, barWidth, segmentHeight - 1);
                    }
                    
                    x += barSpacing;
                }
            }
            
            drawCircle() {
                const sampledData = this.getSampledData();
                const centerX = this.canvasWidth / 2;
                const centerY = this.canvasHeight / 2;
                const radius = 100;
                
                for (let i = 0; i < sampledData.length; i++) {
                    const angle = (i / sampledData.length) * Math.PI * 2;
                    const amplitude = (sampledData[i] / 255) * 200 * this.sensitivity;
                    const intensity = sampledData[i] / 255;
                    
                    const x1 = centerX + Math.cos(angle) * radius;
                    const y1 = centerY + Math.sin(angle) * radius;
                    const x2 = centerX + Math.cos(angle) * (radius + amplitude);
                    const y2 = centerY + Math.sin(angle) * (radius + amplitude);
                    
                    this.ctx.strokeStyle = this.getColor(i, sampledData.length, intensity);
                    this.ctx.lineWidth = 3 * this.barThickness;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, y1);
                    this.ctx.lineTo(x2, y2);
                    this.ctx.stroke();
                }
            }
            
            drawWaveform() {
                const sampledData = this.getSampledData();
                this.ctx.strokeStyle = this.getColor(0, 1, 1);
                this.ctx.lineWidth = 2 * this.barThickness;
                this.ctx.beginPath();
                
                const sliceWidth = this.canvasWidth / sampledData.length;
                let x = 0;
                
                for (let i = 0; i < sampledData.length; i++) {
                    const v = (sampledData[i] / 128) * this.sensitivity;
                    const y = v * this.canvasHeight / 2;
                    
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                    
                    x += sliceWidth;
                }
                
                this.ctx.stroke();
            }
            
            drawParticles() {
                const sampledData = this.getSampledData();
                const avgFreq = sampledData.reduce((a, b) => a + b) / sampledData.length;
                
                this.particles.forEach((particle, index) => {
                    const freqData = sampledData[index % sampledData.length];
                    const intensity = (freqData / 255) * this.sensitivity;
                    
                    particle.x += particle.vx * (1 + intensity);
                    particle.y += particle.vy * (1 + intensity);
                    particle.size = (1 + intensity * 5) * this.barThickness;
                    
                    if (particle.x < 0 || particle.x > this.canvasWidth) particle.vx *= -1;
                    if (particle.y < 0 || particle.y > this.canvasHeight) particle.vy *= -1;
                    
                    this.ctx.fillStyle = this.getColor(particle.hue + avgFreq, 360, intensity);
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }
            
            drawSpiral() {
                const sampledData = this.getSampledData();
                const centerX = this.canvasWidth / 2;
                const centerY = this.canvasHeight / 2;
                
                this.ctx.strokeStyle = this.getColor(0, 1, 1);
                this.ctx.lineWidth = 2 * this.barThickness;
                this.ctx.beginPath();
                
                for (let i = 0; i < sampledData.length; i++) {
                    const angle = (i / sampledData.length) * Math.PI * 8;
                    const amplitude = (sampledData[i] / 255) * 3 * this.sensitivity;
                    const radius = i * 2 + amplitude * 50;
                    
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                
                this.ctx.stroke();
            }
        }
        
        /**
         * ============================================================================
         * COLOR PRESET FUNCTION
         * ============================================================================
         * Sets predefined color schemes for quick styling
         * @param {string} preset - Preset name ('neon', 'ocean', 'sunset', 'cyberpunk')
         */
        function setColorPreset(preset) {
            // Get color input elements
            const color1 = document.getElementById('color1');
            const color2 = document.getElementById('color2');
            const color3 = document.getElementById('color3');
            const colorMode = document.getElementById('colorMode');
            
            // Apply preset color schemes
            switch (preset) {
                case 'neon':
                    color1.value = '#ff0080';  // Hot pink
                    color2.value = '#00ff80';  // Bright green
                    color3.value = '#8000ff';  // Purple
                    colorMode.value = 'custom';
                    break;
                case 'ocean':
                    color1.value = '#006994';  // Deep blue
                    color2.value = '#00a8cc';  // Light blue
                    color3.value = '#b3e5fc';  // Very light blue
                    colorMode.value = 'gradient';
                    break;
                case 'sunset':
                    color1.value = '#ff4081';  // Pink
                    color2.value = '#ff8a50';  // Orange
                    color3.value = '#ffcc02';  // Yellow
                    colorMode.value = 'gradient';
                    break;
                case 'cyberpunk':
                    color1.value = '#ff006e';  // Magenta
                    color2.value = '#00ffff';  // Cyan
                    color3.value = '#ffbe0b';  // Yellow
                    colorMode.value = 'custom';
                    break;
            }
            
            // Update visualizer with new colors
            visualizer.customColors = [color1.value, color2.value, color3.value];
            visualizer.colorMode = colorMode.value;
            // Show/hide custom color controls
            document.getElementById('customColors').style.display = 
                colorMode.value === 'custom' || colorMode.value === 'gradient' ? 'block' : 'none';
        }
        
        // ===== INITIALIZE APPLICATION =====
        // Create the main visualizer instance when page loads
        const visualizer = new AudioVisualizer();
    </script>
</body>
</html>
